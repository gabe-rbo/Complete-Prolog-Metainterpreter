% Esse é o meta interpretador básico do Prolog segundo o livro do
% Bratko.


membro(X, [X|_]).
membro(X, [_|L]) :- membro(X, L).

teste(N1, N3) :-
    membro(N1, L),
    membro(N2, G),
    membro(N3, [N1, N2]).

prove( true) :- !.

prove( clause( Head, Body)) :-
    %dynamic( Head),
    clause( Head, Body).
    % prove( Body).

prove( ( Goal1, Goal2)) :-
    prove( Goal1),
    prove( Goal2).

prove( Goal) :-
    %dynamic(Goal),
    %not(=(Goal, true)),  % Isso resolve o problema de true/0 sem o corte! Mas não
                      % permite que o programa meta-interprete-se
    clause( Goal, Body),
    prove(Body).

% Não é capaz de lidar com predicados embutidos nem com o corte.
% Por causa disso:
% ?- prove(member(X, [a, b, c])).
% false.
% -------------------------------
% ?- prove( prove( member(X, [a, b, c]))).
% ERROR: No permission to access private_procedure `clause/2'
% -----------------------------------------------------------
% >>> Exercicio 23.1:
% O erro ocorre justamente porque ele não pode lidar com o predicado
% embutido clause/2. Uma modificação simples para impedir isso é:
%
%prove( clause( Head, Body)) :-
%    clause( Head, Body).

%prove( A) :-
%    =(A, clause( Head, Body)),
%    clause(Head, Body).
%
% Por algum montivo a solução do Bratko não quer funcionar.
% ?- clause( member(X, L), Body).
% false.
% ------------------------------- ??????????
% A resposta esperada era
% X = _14
% L = [_14 | _15]
% Body = True; ...
%
% ?- [user].
% |: membro(X, [X|_]).
% |: membro(X, [_|L]) :- membro(X, L).
% |: :- dynamic(membro/2).  % Não precisa desse dynamic.
% -------------------------------------
% L = [X|_],
% Body = true ;
% L = [_|_A],
% Body = membro(X, _A)


%:- dynamic(prove/2).
%:- dynamic(prove/1).
%:- dynamic(clause/2).
% Não tenho permissao para alterar um estático embutido.
% Dinamizar prove/1 não funcionou

% O que fez funcionar:
%  Definir a operação que queremos (ex: membro/2).
%
% Problemas:
%  A presença de corte gera erro quando chamos prove/1 com prove/1. Isso
%  não ocorre quando temos prove( true) :- ! e chamamos prove/1 sozinho.
%
